# Copyright (C) 2012 Johan Hake
#
# This file is part of GOSS.
#
# GOSS is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GOSS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with GOSS. If not, see <http://www.gnu.org/licenses/>.

__all__ = ["GossCodeGenerator"]

# Model parameter imports
from modelparameters.parameterdict import ParameterDict

# Gotran imports
from gotran.codegeneration.codegenerator import CppCodeGenerator

from gotran.codegeneration.oderepresentation import ODERepresentation, \
     _default_params
from gotran.common import check_arg
from gotran.model.ode import ODE

_goss_code_generation_params = _default_params(["parameter_numerals", \
                                                "use_parameter_names"])

_codegeneration_doc_str = "\n".join("    {0} : "\
                "bool\n       {1}\n       Default: {2}".format(\
    param.name, param.description, param.value) for param in \
                                    _goss_code_generation_params.values())

_codegeneration_doc_str = """
    A class for generating a C++ subclass of a goss::ODEParameterized

    Arguments:
    ----------
    ode : ODE, ODERepresentation
       The gotran ode, either as an ODE or as an ODERepresentation
{0}
    """.format(_codegeneration_doc_str)

_file_template = """#ifndef {MODELNAME}_H_IS_INCLUDED
#define {MODELNAME}_H_IS_INCLUDED

#include <boost/shared_ptr.hpp>
#include <boost/make_shared.hpp>
#include <stdexcept>
#include <cmath>

#include <goss/Timer.h>
#include <goss/ParameterizedODE.h>

{CLASS_DECLARATION}
#endif
"""

_class_template = """namespace goss {{

  // Implementation of gotran generated ODE
  class {ModelName} : public ParameterizedODE
  {{
  public:

    // Constructor
    {ModelName}() : ParameterizedODE({num_states}, {num_parameters}, {num_field_states}, {num_field_parameters}, {num_monitored}), 
{variable_initialization}
      
    {{
{constructor}
    }}

    // Copy constructor
    {ModelName}(const {ModelName}& ode) : ParameterizedODE(ode),
{variable_initialization_copy_constructor}
    {{
      // Do nothing
    }}

    // Evaluate rhs of the ODE
    void eval(const double* states, double time, double* values)
    {{

      Timer timer_(\"Evaluation of rhs\"); 
{eval_code}
    }}
    
{jacobian_code}{factorizing_code}{fb_substitution_code}{linear_terms_code}{linear_derivatives_code}{eval_componentwise_code}
    // Get default initial conditions
    void get_ic(goss::DoubleVector *values) const
    {{
{initial_condition_code}
    }}

    // Return a copy of the ODE
    boost::shared_ptr<ODE> copy() const
    {{
      return boost::make_shared<{ModelName}>(*this);
    }}

    // Evaluate the monitored intermediates
    void eval_monitored(const double* states, double time, double* monitored) const
    {{

      Timer timer_(\"Evaluation of monitored.\");
{monitored_evaluation_code}
    }}

    // Set all field parameters
    void set_field_parameters(const double* field_params)
    {{
{set_field_parameters_code}
    }}

  private:
{variable_declaration}    

  }};

}}"""

_no_monitored_snippet = """\n      // No monitored
      throw std::runtime_error(\"No monitored in the \\'{0}\\' model.\");"""

_file_form = dict(
  MODELNAME="NOT_IMPLEMENTED",
  CLASS_DECLARATION="NOT_IMPLEMENTED",
)

_class_form = dict(
  ModelName="NOT_IMPLEMENTED",
  linearized_base_initialization="",
  num_states="NOT_IMPLEMENTED",
  num_parameters=0,
  num_field_states=0,
  num_field_parameters=0,
  num_monitored=0,
  state_names_ctr="NOT_IMPLEMENTED",
  variable_initialization="NOT_IMPLEMENTED",
  variable_initialization_copy_constructor="NOT_IMPLEMENTED",
  constructor="",
  eval_code="NOT_IMPLEMENTED",
  initial_condition_code="NOT_IMPLEMENTED",
  monitored_evaluation_code="",
  set_field_parameters_code="",
  variable_declaration="NOT_IMPLEMENTED",
  eval_componentwise_code="",
  linear_terms_code="",
  linear_derivatives_code="",
  jacobian_code="",
  factorizing_code="",
  fb_substitution_code="",
)

class GossCodeGenerator(CppCodeGenerator):
    """
    Class for generating an implementation of a goss ODE
    """
    
    def __init__(self, ode, **options):
        
        if isinstance(ode, ODE):
            params = _goss_code_generation_params.copy()
            params.update(options)
            oderepr = ODERepresentation(ode, **params.copy(True))
        else:
            oderepr = ode

        # Init base class
        params = GossCodeGenerator.default_params()
        params.parameters_in_signature = False
        super(GossCodeGenerator, self).__init__(oderepr, params)
        
        self.file_form = _file_form.copy()
        self.class_form = _class_form.copy()
        name = self.oderepr.name

        self._name = name if name[0].isupper() else name[0].upper() + \
                     (name[1:] if len(name) > 1 else "")

        # Fill the forms with content
        self.file_form["MODELNAME"] = name.upper()
        self.class_form["ModelName"] = self.name
            
        self.class_form["num_states"] = self.oderepr.ode.num_states
        self.class_form["num_parameters"] = self.oderepr.ode.num_parameters
        self.class_form["num_field_states"] = self.oderepr.ode.num_field_states
        self.class_form["num_field_parameters"] = \
                            self.oderepr.ode.num_field_parameters
        self.class_form["num_monitored"] = \
                            self.oderepr.ode.num_monitored_intermediates

        self.class_form["monitored_evaluation_code"] = \
                _no_monitored_snippet.format(oderepr.name.capitalize()) + \
                "\n"
        self._code_generated = False

        
    @property
    def name(self):
        return self._name
    
    def generate_class_code(self):
        """
        Generate the goss class code
        """

        if not self._code_generated:
            self._constructor_body()
            self._variable_init_and_declarations()
            self._eval_code()
            if self.oderepr.ode.num_monitored_intermediates > 0:
                self._monitored_code()

            if self.oderepr.optimization.generate_linearized_evaluation:
                self._eval_linearized_code()
                self._eval_componentwise_code()

            if self.oderepr.optimization.generate_jacobian:
                self._jacobian_code()

            if self.oderepr.optimization.generate_lu_factorization:
                self._factorizing_jacobian_code()

            if self.oderepr.optimization.generate_forward_backward_subst:
                self._fb_substitution_code()

        self._code_generated = True

        return _class_template.format(**self.class_form)

    def generate_file_code(self):
        """
        Generate the goss file code
        """
        self.file_form["CLASS_DECLARATION"] = self.generate_class_code()
        return _file_template.format(**self.file_form)

    def _constructor_body(self):
        """
        Generate code snippets for constructor
        """

        ode = self.oderepr.ode

        # State names
        state_names = [state.name for state in ode.states]
        field_state_names = [state.name for state in ode.field_states]
        body = ["", "// State names"]
        body.extend("_state_names[{0}] = \"{1}\"".format(i, name) \
                    for i, name in enumerate(state_names))

        # Parameter names
        if self.class_form["num_parameters"] > 0:
            body.extend(["", "// Parameter names"])
            body.extend("_parameter_names[{0}] = \"{1}\"".format(\
                i, param.name) for i, param in \
                        enumerate(ode.parameters))
            
        # Field state names
        if self.class_form["num_field_states"] > 0:
            body.extend(["", "// Field state names"])
            body.extend("_field_state_names[{0}] = \"{1}\"".format(\
                i, name) for i, name in enumerate(field_state_names))

            body.extend(["", "// Field state indices"])
            for i, name in enumerate(field_state_names):
                body.append("_field_state_indices[{0}] = {1}".format(\
                    i, state_names.index(name)))
            
        # Field parameter names
        if self.class_form["num_field_parameters"] > 0:
            body.extend(["", "// Field parameter names"])
            body.extend("_field_parameter_names[{0}] = \"{1}\"".format(\
                i, param.name) for i, param in \
                        enumerate(ode.field_parameters))
            
        # Monitored names
        if self.class_form["num_monitored"] > 0:
            body.extend(["", "// Monitored names"])
            body.extend("_monitored_names[{0}] = \"{1}\"".format(\
                i, monitored) for i, monitored in \
                        enumerate(ode.monitored_intermediates))

        # Parameter to value map
        if self.class_form["num_parameters"] > 0:
            body.extend(["", "// Parameter to value map"])
            body.extend("_param_to_value[\"{0}\"] = &{1}".format(\
                param.name, param.name) for i, param in \
                        enumerate(ode.parameters))

        body.append("")
        code = "\n".join(self.indent_and_split_lines(body, indent=3))
            
        self.class_form["constructor"] = code

    def _variable_init_and_declarations(self):
        """
        Generate code snippets for variable declarations, initialization and
        initial conditions
        """

        ode = self.oderepr.ode

        state_declarations = ["", "// State assignments"]
        parameter_declarations = []
        init = []
        init_copy = []

        state_declarations.extend("const double {0} = states[{1}]".format(state.name, i) \
                                  for i, state in enumerate(ode.states))
        
        # Parameter declaration and init
        if self.class_form["num_parameters"] > 0:
            parameter_declarations.extend(["", "// Parameters"])
            parameter_declarations.append("double " + ", ".join(\
                param.name for param in ode.parameters)) 
            
            init.extend("{0}({1})".format(param.name, param.init[0] \
                        if param.is_field else param.init) \
                        for param in ode.parameters)
            init_copy.extend("{0}(ode.{0})".format(param.name) \
                             for param in ode.parameters)
        
        # Parameter initialization
        init = [", ".join(init)]
        code = "\n".join(self.indent_and_split_lines(init, indent=3, \
                                                     no_line_ending=True))
        self.class_form["variable_initialization"] = code
        
        init_copy = [", ".join(init_copy)]
        code = "\n".join(self.indent_and_split_lines(init_copy, indent=3, \
                                                     no_line_ending=True))
        self.class_form["variable_initialization_copy_constructor"] = code
        
        # State declarations
        code = "\n".join(self.indent_and_split_lines(state_declarations,\
                                                     indent=3))
        self.class_form["state_declarations"] = code
        
        # Parameter declaration
        code = "\n".join(self.indent_and_split_lines(parameter_declarations,\
                                                     indent=2))
        self.class_form["variable_declaration"] = code

        # Initial condition code
        ic_code = ["", "// Initial conditions"]
        ic_code.append("values->n = _num_states")
        ic_code.append("values->data.reset(new double[_num_states])")
        ic_code.extend("values->data[{0}] = {1}".format(\
            i, state.init[0] if state.is_field else state.init) \
                       for i, state in enumerate(ode.states))

        code = "\n".join(self.indent_and_split_lines(ic_code, indent=3))

        self.class_form["initial_condition_code"] = code

        # Field parameter setting
        set_field_parameters_code = []
        
        if self.class_form["num_field_parameters"] > 0:
            set_field_parameters_code.extend(["", "// Set field parameters"])
            set_field_parameters_code.extend("{0} = field_params[{1}]".format(\
                param.name, i) for i, param in \
                                    enumerate(ode.field_parameters))

            set_field_parameters_code.append("")
            
            code = "\n".join(self.indent_and_split_lines(\
                set_field_parameters_code, indent=3))
            self.class_form["set_field_parameters_code"] = code

    def _eval_code(self):
        """
        Generate code for the eval method(s)
        """
        
        body = self.dy_body(result_name="values")
        code = "\n".join(self.indent_and_split_lines(body, indent=3))
        self.class_form["eval_code"] = code
        
    def _monitored_code(self):
        """
        Generate code for the monitored method
        """
        body = self.monitored_body(result_name="monitored")
        code = "\n".join(self.indent_and_split_lines(body, indent=3))
        self.class_form["monitored_evaluation_code"] = code

    def _eval_componentwise_code(self):
        body = ["", "Timer timer_(\"Componentwise evaluation of rhs\");", ""]
        body.extend(self.dy_componentwise_body())
        body = self.wrap_body_with_function_prototype(\
            body, "eval", "uint id, const double* states, double time",\
            return_type="double",
            comment="Evaluate componenttwise rhs of the ODE")
        code = "\n".join(self.indent_and_split_lines(body, indent=3))
        self.class_form["eval_componentwise_code"] = "\n"+code+"\n"

    def _eval_linearized_code(self):

        self.oderepr._compute_linearized_dy_cse()
        body = ["indices[{0}] = {1}".format(ind, int(linear)) \
                for ind, linear in enumerate(self.oderepr.linear_terms)]
        body = self.wrap_body_with_function_prototype(\
            body, "linear_terms", "uint* indices",\
            comment="Return the linear terms", const=True)
        code = "\n".join(self.indent_and_split_lines(body, indent=3))
        self.class_form["linear_terms_code"] = "\n"+code+"\n"

        body = ["", "Timer timer_(\"Evaluation of linearized rhs\");", ""]
        body.extend(self.linearized_dy_body(result_name="values"))
        body = self.wrap_body_with_function_prototype(\
            body, "linear_derivatives", "const double* states, double time, double* values",\
            comment="Evaluate the linear derivatives", const=True)
        code = "\n".join(self.indent_and_split_lines(body, indent=3))
        self.class_form["linear_derivatives_code"] = "\n"+code+"\n"
        
    def _jacobian_code(self):
        body = ["", "Timer timer_(\"Jacobian computation\");", ""]
        body.extend(self.jacobian_body(result_name="jac"))
        body = self.wrap_body_with_function_prototype(\
            body, "compute_jacobian", "double* states, double time, double* jac",
            comment="Compute analytic jacobian")
        code = "\n".join(self.indent_and_split_lines(body, indent=2))
        self.class_form["jacobian_code"] = "\n"+code+"\n"
        
    def _factorizing_jacobian_code(self):
        self.oderepr._compute_symbolic_factorization_of_jacobian()
        body = ["", "Timer timer_(\"Factorizing jacobian\");", ""]
        body.extend(self.oderepr._jacobian_factorization_operations)
        body.append("")
        body = self.wrap_body_with_function_prototype(\
            body, "lu_factorize", "double* jac",
            comment="In place LU Factorize matrix (jacobian)", const=True)
        code = "\n".join(self.indent_and_split_lines(body, indent=2))
        self.class_form["factorizing_code"] = "\n"+code+"\n"

    def _fb_substitution_code(self):
        self.oderepr._compute_symbolic_fb_substitution()
        body = ["", "Timer timer_(\"Forward backward substitution\");", ""]
        body.extend(["// Copy b to dx", "for (unsigned int i=0; i<_num_states; i++)"])
        body.append(["dx[i] = b[i]"])
        body.append("")
        body.append("// In place forwards backward substitution")
        body.extend(self.oderepr._jacobian_fb_substitution_operations)
        body.append("")
        body = self.wrap_body_with_function_prototype(\
            body, "forward_backward_subst", "const double* jac, const double* b, double* dx",
            comment="Forward/Backward substitution of factoriesed matrix", const=True)
        code = "\n".join(self.indent_and_split_lines(body, indent=2))
        self.class_form["fb_substitution_code"] = "\n"+code+"\n"
        
# Assign doc string
GossCodeGenerator.__init__.im_func.func_doc = _codegeneration_doc_str
