# Copyright (C) 2013 Johan Hake
#
# This file is part of GOSS.
#
# GOSS is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GOSS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with GOSS. If not, see <http://www.gnu.org/licenses/>.

__all__ = ["DOLFINODESystemSolver"]

from collections import OrderedDict
import numpy as np
import types

import cpp

try:
    import dolfin as d
except:
    raise ImportError("dolfin is not present")

# Check version
from distutils.version import LooseVersion, StrictVersion
if LooseVersion(d.__version__ ) <= LooseVersion("1.2.0"):
    raise ImportError("dolfin version need to be 1.2.0+ or higher")

# Extend goss.ParameterizedODE solver with an interface to attach dolfin.Function
# as spatially varying parameters
def _attach_field_parameter(self, name, values):
    """
    Attach a Function to be used as spatially varying values for a
    field parameter

    Arguments:
    name str
      the name of the field parameter
    values Function
      A Function containing the spatially varying values of
      the field parameter

    """
    assert isinstance(name, str), "expected a str as the name argument"
    assert isinstance(values, d.Function), "expected a Function for the values argument"
    
    field_param_names = self.get_field_parameter_names()

    assert name in field_param_names, "'%s' is not a field parameter in this ode" % name

    if hasattr(self, "field_params"):
        self.field_params[name] = values
    else:
        self.field_params = {name:values}

cpp.ParameterizedODE.attach_field_parameter = types.MethodType(\
    _attach_field_parameter, None, cpp.ParameterizedODE)

_goss_solvers = [name for name, attr in cpp.__dict__.iteritems() \
                 if isinstance(attr, type) and issubclass(attr, cpp.ODESolver)]

_goss_solvers.remove("ODESolver")

class DOLFINODESystemSolver(object):
    """
    DOLFINODESystemSolver is an adapter class for goss.ODESystemSolver
    making interfacing DOLFIN easier
    """
    def __init__(self, mesh, odes, domains=None, params=None):
        """
        Arguments:
        ----------
        mesh : Mesh
           The domain. By default ODE dofs lives on the vertices
        odes : ParameterizedODE, dict
           The ParameterizedODE, to be solved in each vertex. If a dict the
           keys defines the domain and the values defines the ODE should be
           solved on.
        domains : MeshFunction (optional)
           A MeshFunction describing the distribution of the ODEs over the mesh.
        params : dict (optional)
           A dict providing parameters for the Solvers
        """

        assert isinstance(mesh, d.Mesh), "expected a dolfin Mesh for the "\
               "mesh argument"
        assert isinstance(odes, (dict, cpp.ParameterizedODE)), "expected a"\
               " dict or a ParametersizedODE for the odes argument"

        params = params or {}
        
        if isinstance(odes, cpp.ParameterizedODE):
            num_field_states = odes.num_field_states()
            field_names = odes.get_field_state_names()
            odes = {0, odes}
            distinct_domains = [0]
            assert domains is None, "domains only expected when more than 1 "\
                   "ODE is given"
        else:
            assert isinstance(domains, d.MeshFunctionSizet), "expected a "\
                   "MeshFunction as the domains argument when more than "\
                   "1 ODE is given"
            assert domains.dim() == 0, "expected a domains to be a "\
                   "MeshFunction of topological dimension 0"
            
            # Check given domains
            distinct_domains = list(sorted(set(domains.array())))
            assert d.MPI.max(len(distinct_domains)) == \
                   d.MPI.max(len(odes)), "expected the number "\
                   "of distinct domains to be the same as the number of ODEs"

            # FIXME: Does not work if 1 processor only have 1 ode 
            #assert distinct_domains != list(sorted(odes.keys())), "expected "\
            #       "domains given in odes to be the same as the distinct "\
            #       "numbers in the domains argument"
            
            # Check and compare the number of field states
            ode_list = odes.values()
            last_ode = ode_list.pop()
            assert all(last_ode.num_field_states() == ode.num_field_states() \
                       for ode in ode_list), "expected all odes to have the "\
                       "same number of field states"
            
            last_field_state_names = last_ode.get_field_state_names()
            assert all(last_ode.get_field_state_names() == \
                       ode.get_field_state_names() for ode in ode_list), \
                       "expected all odes to have the same name and order "\
                       "of the field states (Might be changed in the future.)"

            num_field_states = last_ode.num_field_states()
            field_names = last_ode.get_field_state_names()

        # Create dof storage for the dolfin function
        if num_field_states > 1:
            V = d.VectorFunctionSpace(mesh, "CG", 1, dim=num_field_states)
        else:
            V = d.FunctionSpace(mesh, "CG", 1)

        # Get the dof to vertex and the vertex to dof mappings
        dof_to_vertex = d.dof_to_vertex_map(V)
        num_local_dofs = len(dof_to_vertex)
        vertex_to_dof = d.vertex_to_dof_map(V)
        first_dof, last_dof = V.dofmap().ownership_range()
        
        # Extract dof information (Potentially slow?)
        # Vectorize!?
        dof_maps = {}
        goss_values = {}
        num_dofs = {}
        goss_indices = {}
        
        for label in distinct_domains:
            dof_maps[label] = OrderedDict((key, []) for key in field_names)
            for vert in (d.SubsetIterator(domains, label) \
                    if domains else d.vertices(mesh)):
                for local_dof_offset in range(num_field_states):
                    local_dof = vertex_to_dof[\
                        vert.index()*num_field_states+local_dof_offset]
                    if 0 <= local_dof < num_local_dofs:
                        dof_maps[label][field_names[local_dof_offset]].append(\
                            local_dof)
            
            # Check we have the same number of dofs per field name.
            # This is probably not the case in parallel when several
            # field states are used. It needs issue # 21 to be fixed in dolfin
            if len(field_names) > 1:
                assert all(len(dof_maps[label][field_names[0]]) == \
                           dof_maps[label][field_name] for field_name in \
                           field_names[1:]), "expected all "\
                           "fields to have the same number of dofs"
            
            # Num dofs per field state per label (only store one of the
            # field states as it has to be the same for all field states)
            num_dofs[label] = len(dof_maps[label][field_names[0]])

            # Store the dofs as numpy arrays
            for names, value in dof_maps[label].items():
                dof_maps[label][names] = np.array(value, dtype=np.intc)
            
            # Allocate memory for value transfer to ODESystemSolver
            goss_values[label] = np.zeros(num_dofs[label]*num_field_states, \
                                          dtype=np.float_)

            # Create a nested index set for putting values into field_states
            # in a ODESystemSolver
            goss_indices[label] = OrderedDict((key, \
                np.arange(offset, num_dofs[label]+offset, num_field_states, \
                          dtype=np.intc)) for offset, key in enumerate(field_names))

        # allocate memory for accessing values from DOLFIN Function
        self._dolfin_values = np.concatenate(tuple(value for value in goss_values.values()))

        # An dof index array used to access the dofs from the dolfin vector
        dof_maps["dolfin"] = np.arange(len(self._dolfin_values), dtype=np.intc) + first_dof
        
        # Store arguments
        self._mesh = mesh
        self._odes = odes
        self._domains = domains
        self.params = self.default_parameters()
        self.params.update(params)

        # Instantiate the solver
        solver = eval(self.params["scheme"] , cpp.__dict__, {})()
        
        # Instantiate the ODESystemSolvers
        self._ode_system_solvers = [cpp.ODESystemSolver(\
            num_dofs[label], solver.copy(), odes[label]) for label in distinct_domains]

        # Set num of threads
        for solver in self._ode_system_solvers:
            solver.set_num_threads = self.params["num_threads"]
        
        # Store dof mapping and field value storages
        self._dof_maps = dof_maps
        self._goss_values = goss_values
        self._goss_indices = goss_indices
        self._num_dofs = num_dofs
        self._field_names = field_names
        self._num_field_states = len(field_names)
        self._num_distinct_domains = len(distinct_domains)
        self._distinct_domains = distinct_domains

    @property
    def field_names(self):
        return self._field_names

    @property
    def num_distrinct_domains(self):
        return self._num_distinct_domains

    def default_parameters(self):

        params = d.Parameters("DOLFINODESystemSolver")
        params.add("scheme", "ImplicitEuler", _goss_solvers)
        params.add("num_threads", 0, 0, 100)
        
        return params

    
    def step(self, interval, v):
        """
        Solve on the given time step (t0, t1).
        
        End users are recommended to use solve instead.
        
        Arguments:
        interval : tuple
          The time interval (t0, t1) for the step
        """

        assert isinstance(v, d.Function)

        timer = d.Timer("ODE step")
        (t0, t1) = interval
        dt = t1 - t0
        
        # Get values from dolfin
        values = self._dolfin_values
        v.vector().get_local(values, self._dof_maps["dolfin"])

        # Update solver with new field_state values
        for label, ode_system_solver in zip(self._distinct_domains, \
                                            self._ode_system_solvers):

            # Iterate over the fields and collect values
            for field_name in self._field_names:
                goss_indices = self._goss_indices[label][field_name]
                dof_maps = self._dof_maps[label][field_name]

                # Get each field for each distinct domain
                self._goss_values[label][goss_indices] = values[dof_maps]

            # Transfer values to Solver
            ode_system_solver.set_field_states(self._goss_values[label])
            
            # Step solver
            ode_system_solver.forward(t0, dt)

            # Fetch solution and put back into dolfin function
            ode_system_solver.get_field_states(self._goss_values[label])

            # Iterate over the fields and collect values and put back
            # into dolfin transit array
            for field_name in self._field_names:
                goss_indices = self._goss_indices[label][field_name]
                dof_maps = self._dof_maps[label][field_name]

                # Get each field for each distinct domain
                values[dof_maps] = self._goss_values[label][goss_indices]
        
        # Put solution back into DOLFIN Function
        v.vector().set(values, self._dof_maps["dolfin"])

